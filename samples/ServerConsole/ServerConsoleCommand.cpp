#include "ServerConsolePCH.h"
#include "ServerConsoleCommand.h"

using namespace cz;


/* Parses a string as a command, where the first word is a command, followed by comma
separated parameters:
command param1,param2,param2
parameters can be numbers, strings, or file contents (contents of the file will be loaded):
command 100,100.5,"Hello", !"filename.txt"

returns the command and the parameters
*/
static GenericCommand parseCommandParameters(const std::string& str)
{
	GenericCommand empty;
	GenericCommand cmd;

	std::string trimmed = cz::trim(str);
	std::stringstream ss(trimmed);
	std::string token;
	// read command
	if (!std::getline(ss, token, ' '))
		return std::move(empty);

	// Get connection name (if any) and command 
	{
		std::stringstream sstoken(token);
		if (token.find('.')!=std::string::npos)
		{
			if (!std::getline(sstoken, cmd.conName, '.'))
				return std::move(empty);
		}
		sstoken >> cmd.cmd;
		if (sstoken.peek()!= EOF)
			return std::move(empty);
	}

	// read all parameters
	while(std::getline(ss, token, ','))
	{
		token = cz::trim(token);
		std::stringstream sstoken(token);
		int i;
		std::string s;
		// first try to read integer (doesn't have a '.')
		// This is needed to differentiate between integer and float.
		int ch = sstoken.peek();
		if (ch>='0' && ch<='9')
		{
			float f;
			if (token.find('.')==std::string::npos && (sstoken >> i))
				cmd.params.emplace_back(i);
			else if (sstoken >> f)
				cmd.params.emplace_back(f);
			else
				return std::move(empty);
		}
		else if (ch=='"') // is a string
		{
			char tmpch;
			sstoken >> tmpch;
			if (!std::getline(sstoken, s, '"'))
				return std::move(empty);
			cmd.params.emplace_back(s.c_str());
			if (sstoken.peek()!= EOF)
				return std::move(empty);
		}
		else if (token=="false" || token=="FALSE")
		{
			cmd.params.emplace_back(false);
		}
		else if (token=="true" || token=="TRUE")
		{
			cmd.params.emplace_back(true);
		}
		else if (ch=='!') // it's a file's content
		{
			char tmpch;
			sstoken >> tmpch;
			if (sstoken.peek()=='"')
			{
				sstoken >> tmpch;
				if (!std::getline(sstoken, s, '"'))
					return std::move(empty);
			}
			else
			{
				sstoken >> s;
			}

			if (sstoken.peek()!=EOF)
				return std::move(empty);

			std::ifstream f(s.c_str(), std::ios::binary);
			if (!f.is_open())
				return std::move(empty);
			std::vector<uint8_t> contents((std::istreambuf_iterator<char>(f)),
				std::istreambuf_iterator<char>());
			cmd.params.emplace_back(std::move(contents));
		}

		else
			return std::move(empty);
	}

	return std::move(cmd);
}

using InternalCommandFunc = void(*)(const std::vector<cz::rpc::Any>&);
struct InternalCommand
{
	const char* shortName;
	const char* longName;
	InternalCommandFunc handler;
	const char* help;
};

void cmd_Help(const std::vector<cz::rpc::Any>&);

void setupConInfo_2(std::shared_ptr<ConInfo> conInfo)
{
	// If name property is not set, we give an autogenerated name to the connection
	static int counter = 0;

	// Loop until we generate a valid name
	while (conInfo->name == "" || gData->cons.find(conInfo->name) != gData->cons.end())
	{
		if (conInfo->name == "")
		{
			conInfo->name = "con" + std::to_string(counter++);
			std::cout << "Server did not provide a name. Trying auto generated name '" << conInfo->name << "'\n";
		}
		else
		{
			std::cout << "An active connection with name '" << conInfo->name << "' already exists.\n";
			conInfo->name = "con" + std::to_string(counter++);
			std::cout << "Trying auto generated name '" << conInfo->name << "'\n";
		}
	}

	std::cout << "Adding connection to " << conInfo->addr.to_string() << " as '" << conInfo->name << "'\n";
	gData->cons[conInfo->name] = conInfo;
	conInfo->con.setOnDisconnect([conInfo]
	{
		std::cout << "Connection '" << conInfo->name << "' disconnected\n";
		gData->cons.erase(conInfo->name);
	});
}

void setupConInfo_1(std::shared_ptr<ConInfo> conInfo)
{
	// Try to get the name from the server (if any)
	CZRPC_CALLGENERIC(conInfo->con, "__getProperty", std::vector<Any>{Any("name")}).async(
		[conInfo](rpc::Result<Any> res)
	{
		if (!res.isValid())
		{
			std::cout << "Call to __getProperty failed\n";
			return;
		}

		conInfo->name = res.get().toString();
		setupConInfo_2(conInfo);
	});
}

void cmd_Connect(const std::vector<cz::rpc::Any>& params)
{
	std::tuple<std::string> p;
	if (!toTuple(params, p))
	{
		std::cout << "Invalid number/type of parameters\n";
		return;
	}

	auto tmp = splitAddress(std::get<0>(p));
	auto conInfo = std::make_shared<ConInfo>(gData->service);
	conInfo->addr.ip = tmp.first;
	conInfo->addr.port = tmp.second;

	for(auto&& it : gData->cons)
	{
		if (it.second->addr==conInfo->addr)
		{
			std::cout << "There is already an active connection with address " << conInfo->addr.to_string() << "\n";
			return;
		}
	}

	conInfo->trp.asyncConnect(conInfo, conInfo->con, conInfo->addr.ip.c_str(), conInfo->addr.port,
		[conInfo](const spas::Error& ec)
	{
		if (ec)
		{
			std::cout << "Could not connect to the specified address (" << conInfo->addr.to_string() << ")\n";
			return;
		}

		setupConInfo_1(conInfo);
	});
}

void cmd_ShutdownConnection(const std::vector<cz::rpc::Any>& params)
{
	std::tuple<std::string> p;
	if (!toTuple(params, p))
	{
		std::cout << "Invalid number/type of parameters\n";
		return;
	}

	auto it = gData->cons.find(std::get<0>(p));
	if (it != gData->cons.end())
	{
		std::cout << "Closing connection " << it->second->name << "\n";
		it->second->con.close();
	}
	else
	{
		std::cout << "No connection with name " << std::get<0>(p) << " found.\n";
	}
}

void cmd_Resume(const std::vector<cz::rpc::Any>&)
{
	std::cout << "Resuming..." << std::endl;
}

void cmd_Quit(const std::vector<cz::rpc::Any>&)
{
	std::cout << "Quitting..." << std::endl;
	gData->finish = true;
}

void cmd_List(const std::vector<cz::rpc::Any>&)
{
	std::cout << "Connections list:" << std::endl;
	if (gData->cons.size())
	{
		for (auto& c : gData->cons)
		{
			std::cout << "    " << c.first << " @ " << c.second->addr.to_string() << std::endl;
		}
	}
	else
	{
		std::cout << "    No active connections";
	}

	std::cout << std::endl;
}

InternalCommand gCmds[] =
{
	{
		"h", "help", &cmd_Help,
		"Display this help"
	},
	{
		"c", "connect", &cmd_Connect,
		"\n" \
		"    Connects to a server.\n" \
		"    Format: connect \"ip:port\""
	},
	{
		"x", "shutdown", &cmd_ShutdownConnection,
		"\n" \
		"    Closes the specified connection.\n" \
		"    Format: shutdown \"name\""
	},

	{
		"r", "resume", &cmd_Resume,
		"Exit command mode and continue"
	},
	{
		"l", "list", &cmd_List,
		"List all active connections"
	} ,
	{
		"q", "quit", &cmd_Quit,
		"Quit the application"
	}
};

void cmd_Help(const std::vector<cz::rpc::Any>&)
{
	std::cout <<
		"Help\n" \
		"To enter a command, just type it. It will go into command mode.\n" \
		"Internal commands start with ':' and have the following format:\n" \
		"    :cmd p1, p2, ...\n" \
		"    Where p1,p2,... are any parameters required\n" \
		"Anything that doesn't start with a ':' is interpreted as an RPC, and has the following format:\n" \
		"    con_name.rpcname p1, p2, ...\n" \
		"    Where con_name is the connection name, rpcname the rpc to call, and p1,p2,... the parameters\n" \
		"";
	std::cout << "List of internal commands" << std::endl;
	for(auto&& p : gCmds)
	{
		std::cout << "(" << p.shortName << ")" << p.longName << ": " << p.help << std::endl;
	}
}

void processCommand(const std::string& str)
{
		GenericCommand cmd = parseCommandParameters(str);
		if (cmd.cmd.size()==0)
		{
			std::cout << "INVALID COMMAND" << std::endl;
			return;
		}

		// Process local command
		if (cmd.cmd[0]==':')
		{
			cmd.cmd.erase(cmd.cmd.begin());

			InternalCommand* cmdPtr = nullptr;
			for(auto&& p : gCmds)
			{
				if (cmd.cmd == p.shortName || cmd.cmd == p.longName)
					return p.handler(cmd.params);
			}
			
			std::cout << "Unknown local command (" << cmd.cmd << ")" << std::endl;
			return;
		}

		// Process an RPC command
		if (cmd.conName=="")
		{
			std::cout << "Connection not specified. " << std::endl;
			return;
		}

		auto it = gData->cons.find(cmd.conName);
		if (it == gData->cons.end())
		{
			std::cout << "Connection " << cmd.conName << " not found" << std::endl;
			return;
		}

		CZRPC_CALLGENERIC(it->second->con, cmd.cmd.c_str(), cmd.params).async(
			[funcName=cmd.cmd](Result<Any> res)
		{
			if (res.isAborted())
				return;

			if (res.isException())
			{
				std::cout << "RESPONSE FOR " << funcName << " : " << res.getException() << std::endl;
			}
			else
			{
				std::cout << "RESPONSE FOR " << funcName << " : " << res.get().toString() <<  std::endl;
			}
		});

}

